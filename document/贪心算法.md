# 贪心算法  
>贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。

- 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而**希望导致**结果是全局最好或最优的算法。
- 然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。
- 一旦一个问题可以通过贪心算法来解决，那么贪心法一般是解决这个问题的最好办法。
- 由于贪心算法的高效性及其得到答案比较接近最优解，可以用作辅助算法或者精确度要求不高的问题的解法



## 使用场景
>问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解，这种子问题最优解称为最优子结构

针对一组数据，我们定义了**限制值**和**期望值**，希望从中选出几个数据，在满足限制值的情况下，期望值最大
比如：
假设有一个可以容纳 100kg 物品的背包，可以装各种物品。有 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？

## 可能适用场景
每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。
比如：
每次都从剩下的豆子里面，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子。

**用贪心算法解决问题的思路，并不总能给出最优解。**
主要原因是，前面的选择，会影响后面的选择。即便第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。

## 应用一：区间覆盖
假设有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？
![区间覆盖](../images/tanxin01.jpg)

### 思路
假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。
每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。
![区间覆盖](../images/tanxin02.jpg)

## 应用二：用贪心算法实现霍夫曼编码
假设有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？

### 思路一
将字符用二进制位表示
假设这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了
```shell
a(000)、b(001)、c(010)、d(011)、e(100)、f(101)
```

### 思路二：霍夫曼编码
为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。
假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，
![区间覆盖](../images/tanxin03.jpg)
在解压缩的时候，每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。


#### 如何根据字符出现频率的不同，给不同的字符进行不同长度的编码？
>该算法是贪婪算法的原因在于，在每一阶段我们都进行一次合并而没有进行全局的考虑。我们只是选择两颗最小的树。

把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。
![区间覆盖](../images/tanxin04.jpg)

现在，给每一条边加上画一个权值，指向左子节点的边统统标记为 0，指向右子节点的边，统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。
![区间覆盖](../images/tanxin05.jpg)


## 贪心算法和动态规划的区别
#### 贪心
- 对每个子问题的解决方案都作出选择，都会选择当前最优的那个，不能回退

#### 动归
- 会保存以前的结果，并根据以前的结果对当前进行选择，有回退的功能



