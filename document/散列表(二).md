# 散列表

## 设计散列函数
>如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？
- 散列函数的设计不能太复杂
- 散列函数生成的值要尽可能随机并且均匀分布
- 实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。

## 装载因子过大了怎么办
装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。

对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。
对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。

针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，需要通过散列函数重新计算每个数据的存储位置。

## 如何避免低效的扩容
为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。
当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。
通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)

## 冲突解决方法比较
### 开放寻址法
>Java 中 LinkedHashMap
优点：
- 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。
- 序列化起来比较简单。

缺点：
- 删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。
- 所有的数据都存储在一个数组中，更容易冲突。
- 装载因子的上限不能太大，更浪费内存空间。



### 链表法
> ThreadLocalMap
优点：
- 对内存的利用率高，不需要事先申请
- 对大装载因子的容忍度更高。只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已

缺点：
- 链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。
- 结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，对于执行效率也有一定的影响。
- 实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。

### 总结
基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。    

## 散列表和链表的应用
- Redis跳表
- Java LinkedHashMap
- LRU 缓存淘汰算法
- Redis 有序集合






