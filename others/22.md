## 22. Generate Parentheses
Medium
>链接：https://leetcode-cn.com/problems/generate-parentheses

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例：
```shell
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```
### 思路一：递归
- 找最近重复子问题，每次增加一个左括号或右括号
- 找递归终止条件，左括号的个数=右括号的个数=n
- 当前层的处理逻辑，通过判断左右括号的个数以及与n的大小关系增加一个左括号或右括号
- 将当前得到的括号组合作为参数进入下一层
- 清理当前环境（如果需要）

#### 代码实现
```python
class Solution:
    def __init__(self):
        self.result = []
    def generateParenthesis(self, n: int) -> List[str]:
        left, right, res = 0, 0, ''
        self.generator(left, right, n, res)
        return self.result
    def generator(self, left, right, n, res):
        if left == n and right == n:
            self.result.append(res)
            return self.result
        if left < n:
            self.generator(left + 1, right, n, res + '(')
        if right < left:
            self.generator(left, right + 1, n, res + ')')
```

### 思路二：动态规划
当用第n对括号生成新元素时，说明前n-1对括号都已经完成了其所有可能且有效的组合，那么处理第n对括号时，要做的看这对括号如何加入前n-1的各个组合中
对于前n-1对括号的每个组合，由于有效的组合必须是左括号开始，所以可以将第n对括号的左括号固定在最左边，将右括号从其右边开始一直往右移动，直到这个组合的最后一个位置，这里记其位置为i
所以第n个括号的所有可能为
"(" + [第i个位置对应的这部分括号的所有组合] + ")" + [剩下 n-1 -i 对括号的所有组合]
DP方程：opt[i] = "(" + 【i=p时所有括号的排列组合】 + ")" + 【i=q时所有括号的排列组合】, 其中 p + q = n-1，且 p q 均为非负整数。

#### 代码实现
```python
class Solution:
    def __init__(self):
        self.result = []
    def generateParenthesis(self, n: int) -> List[str]:
        if n == 0: return []
        res = [[""]]
        for i in range(1, n+1):
            level_list = []
            for j in range(i):
                list_left = res[j]
                list_right = res[i - 1 - j]
                for left in list_left:
                    for right in list_right:
                        cur = f'({left}){right}'
                        level_list.append(cur)
            res.append(level_list)
        return res[n]
```
简化版：
```python
class Solution:
    def __init__(self):
        self.result = []
    def generateParenthesis(self, n: int) -> List[str]:
        dp = [[] for i in range(n + 1)]
        dp[0].append('')
        for i in range(n + 1):
            for j in range(i):
                dp[i] += [f'({x}){y}' for x in dp[j] for y in dp[i - j - 1]]
        return dp[n]
```


